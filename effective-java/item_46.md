# ì•„ì´í…œ 46. ìŠ¤íŠ¸ë¦¼ì—ì„œëŠ” ë¶€ì‘ìš© ì—†ëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë¼

- [ì•„ì´í…œ 46. ìŠ¤íŠ¸ë¦¼ì—ì„œëŠ” ë¶€ì‘ìš© ì—†ëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë¼](#ì•„ì´í…œ-46-ìŠ¤íŠ¸ë¦¼ì—ì„œëŠ”-ë¶€ì‘ìš©-ì—†ëŠ”-í•¨ìˆ˜ë¥¼-ì‚¬ìš©í•˜ë¼)
  - [ìŠ¤íŠ¸ë¦¼ íŒ¨ëŸ¬ë‹¤ì„ì˜ í•µì‹¬](#ìŠ¤íŠ¸ë¦¼-íŒ¨ëŸ¬ë‹¤ì„ì˜-í•µì‹¬)
  - [í…ìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ë‹¨ì–´ë³„ ìˆ˜ë¥¼ ì„¸ì–´ ë¹ˆë„í‘œë¥¼ ë§Œë“œëŠ” ì½”ë“œ](#í…ìŠ¤íŠ¸-íŒŒì¼ì—ì„œ-ë‹¨ì–´ë³„-ìˆ˜ë¥¼-ì„¸ì–´-ë¹ˆë„í‘œë¥¼-ë§Œë“œëŠ”-ì½”ë“œ)
  - [Collector](#collector)
  - [ë¹ˆë„í‘œì—ì„œ ê°€ì¥ í”í•œ ë‹¨ì–´ 10ê°œë¥¼ ë½‘ì•„ë‚´ëŠ” ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸ ì½”ë“œ](#ë¹ˆë„í‘œì—ì„œ-ê°€ì¥-í”í•œ-ë‹¨ì–´-10ê°œë¥¼-ë½‘ì•„ë‚´ëŠ”-ìŠ¤íŠ¸ë¦¼-íŒŒì´í”„ë¼ì¸-ì½”ë“œ)
  - [Collectorsì˜ ë‚˜ë¨¸ì§€ 36ê°œ ë©”ì„œë“œë“¤](#collectorsì˜-ë‚˜ë¨¸ì§€-36ê°œ-ë©”ì„œë“œë“¤)
  - [í•µì‹¬ ì •ë¦¬](#í•µì‹¬-ì •ë¦¬)

ìŠ¤íŠ¸ë¦¼ì„ ì²˜ìŒ ë´ì„œëŠ” ì´í•´í•˜ê¸° ì–´ë ¤ìš¸ ìˆ˜ ìˆë‹¤.

- ì›í•˜ëŠ” ì‘ì—…ì„ ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ í‘œí˜„í•˜ëŠ” ê²ƒì¡°ì°¨ ì–´ë ¤ìš¸ì§€ ëª¨ë¥´ê³ 
- ì„±ê³µí•˜ì—¬ í”„ë¡œê·¸ë¨ì´ ë™ì‘í•˜ë”ë¼ë„ ì¥ì ì´ ë¬´ì—‡ì¸ì§€ ì‰½ê²Œ ì™€ ë‹¿ì§€ ì•Šì„ ìˆ˜ë„ ìˆë‹¤.

ì™œëƒí•˜ë©´, **ìŠ¤íŠ¸ë¦¼ì€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì— ê¸°ì´ˆí•œ íŒ¨ëŸ¬ë‹¤ì„**ì´ê¸° ë•Œë¬¸ì—

## ìŠ¤íŠ¸ë¦¼ íŒ¨ëŸ¬ë‹¤ì„ì˜ í•µì‹¬

ìŠ¤íŠ¸ë¦¼ íŒ¨í„°ë‹¤ì„ì˜ í•µì‹¬ì€ ê³„ì‚°ì„ **ì¼ë ¨ì˜ ë³€í™˜(transformation)**ìœ¼ë¡œ ì¬êµ¬ì„±í•˜ëŠ” ë¶€ë¶„ì´ë‹¤.

-> ì´ë•Œ ê° ë³€í™˜ ë‹¨ê³„ëŠ” ê°€ëŠ¥í•œ ì´ì „ ë‹¨ê³„ì˜ ê²°ê³¼ë¥¼ ë°›ì•„ ì²˜ë¦¬í•˜ëŠ” ìˆœìˆ˜í•¨ìˆ˜ì—¬ì•¼í•œë‹¤.

> ìˆœìˆ˜í•¨ìˆ˜ë€?
>
> ì˜¤ì§ ì…ë ¥ë§Œì´ ê²°ê³¼ì— ì˜í–¥ì„ ì£¼ëŠ” í•¨ìˆ˜ <br>
> ë‹¤ë¥¸ ê°€ë³€ ìƒíƒœë¥¼ ì°¸ì¡°í•˜ì§€ ì•Šê³ , í•¨ìˆ˜ ìŠ¤ìŠ¤ë¡œë„ ë‹¤ë¥¸ ìƒíƒœë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤.

([Pure_function](https://en.wikipedia.org/wiki/Pure_function), [Function (mathematics)](<https://en.wikipedia.org/wiki/Function_(mathematics)>))

ì´ë ‡ê²Œ í•˜ë ¤ë©´, (ì¤‘ê°„ ë‹¨ê³„ë“  ì¢…ë‹¨ ë‹¨ê³„ë“ ) ìŠ¤íŠ¸ë¦¼ ì—°ì‚°ì— ê±´ë„¤ëŠ” í•¨ìˆ˜ ê°ì²´ëŠ” ëª¨ë‘ ë¶€ì‘ìš©(side effect)ì´ ì—†ì–´ì•¼ í•œë‹¤.

## í…ìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ë‹¨ì–´ë³„ ìˆ˜ë¥¼ ì„¸ì–´ ë¹ˆë„í‘œë¥¼ ë§Œë“œëŠ” ì½”ë“œ

```kotlin
val freq = mutableMapOf<String, Long>() as HashMap
try {
    val words = Scanner(wordFile).tokens()
    words.forEach { word ->
        freq.merge(word.toLowerCase(), 1L, Long::plus)
    }
} catch (e: Exception) {
    e.printStackTrace()
}
```

<details>
<summary>ìœ„ì˜ ì½”ë“œì—ì„œ ë¬´ì—‡ì´ ë¬¸ì œì¸ì§€ ë³´ì´ëŠ”ê°€?</summary>
<p>
ìŠ¤íŠ¸ë¦¼, ëŒë‹¤, ë©”ì„œë“œ ì°¸ì¡°ë¥¼ ì‚¬ìš©í–ˆê³ , ê²°ê³¼ë„ ì˜¬ë°”ì§€ë§Œ,

ìŠ¤íŠ¸ë¦¼ ì½”ë“œë¥¼ ê°€ì¥í•œ ë°˜ë³µì  ì½”ë“œì´ê¸° ë•Œë¬¸ì— ì ˆëŒ€ ìŠ¤íŠ¸ë¦¼ ì½”ë“œë¼ í•  ìˆ˜ ì—†ë‹¤.

</p>
</details>

ìŠ¤íŠ¸ë¦¼ APIì˜ ì´ì ì„ ì‚´ë¦¬ì§€ ëª»í•˜ì—¬ ê°™ì€ ê¸°ëŠ¥ì˜ ë°˜ë³µì  ì½”ë“œë³´ë‹¤ (ì¡°ê¸ˆ ë”)

- ê¸¸ê³ ,
- ì½ê¸° ì–´ë µê³ ,
- ìœ ì§€ë³´ìˆ˜ì—ë„ ì¢‹ì§€ ì•Šë‹¤.

ì´ ì½”ë“œì˜ ëª¨ë“  ì‘ì—…ì´ ì¢…ë‹¨ ì—°ì‚°ì¸ `forEach`ì—ì„œ ì¼ì–´ë‚˜ëŠ”ë°,

ì´ë•Œ ì™¸ë¶€ ìƒíƒœ(ë¹ˆë„í‘œ)ë¥¼ ìˆ˜ì •í•˜ëŠ” ëŒë‹¤ë¥¼ ì‹¤í–‰í•˜ë©´ì„œ ë¬¸ì œê°€ ìƒê¸´ë‹¤.

`forEach`ê°€ ê·¸ì € ìŠ¤íŠ¸ë¦¼ì´ ìˆ˜í–‰í•œ ì—°ì‚° ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ” ì¼ ì´ìƒì„ í•˜ëŠ” ê²ƒì„ ë³´ë‹ˆ

ë‚˜ìœ ì½”ë“œ(?)ì¼ ê²ƒ ê°™ì€ ëƒ„ìƒˆ(?)ê°€ ë‚œë‹¤.

ì´ì œ ì˜¬ë°”ë¥´ê²Œ ì‘ì„±í•œ ì½”ë“œë¥¼ ë³´ì.

```kotlin
var freq : Map<String, Long>? = null
try {
    val words = Scanner(wordFile).tokens()
    freq = words
            .collect(groupingBy(String::toLowerCase, counting()))
} catch (e: Exception) {
    e.printStackTrace()
}
```

ì•ì„  ì½”ë“œì™€ ê°™ì€ ì¼ì„ í–ˆì§€ë§Œ, ìŠ¤íŠ¸ë¦¼ì„ ì œëŒ€ë¡œ ì¼ë‹¤. ë¿ë§Œ ì•„ë‹ˆë¼ ì§§ê³  ëª…í™•í•˜ë‹¤.

`forEach`ì—°ì‚°ì€ ëŒ€ë†“ê³  ë°˜ë³µì ì´ë©° ë³‘ë ¬í™”í•  ìˆ˜ ë„ ì—†ê¸° ë•Œë¬¸ì—, **ìŠ¤íŠ¸ë¦¼ ê³„ì‚° ê²°ê³¼ë¥¼ ë³´ê³ í•  ë•Œë§Œ ì‚¬ìš©í•˜ê³ , ê³„ì‚°í•˜ëŠ” ë°ëŠ” ì“°ì§€ ë§ì.**

ìœ„ ì½”ë“œëŠ” ìˆ˜ì§‘ê¸°(collector)ë¥¼ ì‚¬ìš©í•˜ëŠ”ë°, ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ë ¤ë©´ ë°˜ë“œì‹œ ë°°ì›Œì•¼ í•˜ëŠ” ìƒˆë¡œìš´ ê°œë…ì´ë‹¤.

## Collector

`java.util.stream.Collectors`í´ë˜ìŠ¤ëŠ” ë©”ì„œë“œë¥¼ ë¬´ë ¤ 39ê°œ(ìë°” 10ì—ì„œëŠ” 43ê°œ)ë‚˜ ê°€ì§€ê³  ìˆê³ ,

ê·¸ ì¤‘ì—ëŠ” íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ 5ê°œë‚˜ ë˜ëŠ” ê²ƒë„ ìˆë‹¤.

```java
public static <T, K, D, A, M extends Map<K, D>>
    Collector<T, ?, M> groupingBy(Function<? super T, ? extends K> classifier,
                                  Supplier<M> mapFactory,
                                  Collector<? super T, A, D> downstream) {
        Supplier<A> downstreamSupplier = downstream.supplier();
        BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
        BiConsumer<Map<K, A>, T> accumulator = (m, t) -> {
            K key = Objects.requireNonNull(classifier.apply(t), "element cannot be mapped to a null key");
            A container = m.computeIfAbsent(key, k -> downstreamSupplier.get());
            downstreamAccumulator.accept(container, t);
        };
        BinaryOperator<Map<K, A>> merger = Collectors.<K, A, Map<K, A>>mapMerger(downstream.combiner());
        @SuppressWarnings("unchecked")
        Supplier<Map<K, A>> mangledFactory = (Supplier<Map<K, A>>) mapFactory;

        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
            return new CollectorImpl<>(mangledFactory, accumulator, merger, CH_ID);
        }
        else {
            @SuppressWarnings("unchecked")
            Function<A, A> downstreamFinisher = (Function<A, A>) downstream.finisher();
            Function<Map<K, A>, M> finisher = intermediate -> {
                intermediate.replaceAll((k, v) -> downstreamFinisher.apply(v));
                @SuppressWarnings("unchecked")
                M castResult = (M) intermediate;
                return castResult;
            };
            return new CollectorImpl<>(mangledFactory, accumulator, merger, finisher, CH_NOID);
        }
    }

// ...
// Type parameters:
// <T> â€“ the type of the input elements
// <K> â€“ the type of the keys
// <D> â€“ the result type of the downstream reduction
// <A> â€“ the intermediate accumulation type of the downstream collector
// <M> â€“ the type of the resulting Map
// ...

```

ë‹¤í–‰íˆ ë³µì¡í•œ ì„¸ë¶€ ë‚´ìš©ì€ ëª°ë¼ë„, ì´ APIì˜ ì¥ì ì„ ëŒ€ë¶€ë¶„ í™œìš©í•  ìˆ˜ ìˆë‹¤.

ê·¸ëŸ¬ë‹ˆ, ìº¡ìŠí™”í•œ ë¸”ë™ë°•ìŠ¤ë¼ ìƒê°í•˜ë©´ í¸í•˜ë‹¤.

ìˆ˜ì§‘ê¸°ê°€ ìƒì„±í•˜ëŠ” ê°ì²´ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì»¬ë ‰ì…˜ì´ë©°, ê·¸ë˜ì„œ "collector"ë¼ëŠ” ì´ë¦„ì„ ì“´ë‹¤.

ìˆ˜ì§‘ê¸°ë¥¼ ì‚¬ìš©í•˜ë©´ ìŠ¤íŠ¸ë¦¼ì˜ ì›ì†Œë¥¼ ì†ì‰½ê²Œ ì»¬ë ‰ì…˜ìœ¼ë¡œ ëª¨ì„ ìˆ˜ ìˆë‹¤.

ìˆ˜ì§‘ê¸°ëŠ” ì´ ì„¸ ê°€ì§€ë¡œ, `toList()`, `toSet()`, `toCollection(collectionFactory)`ê°€ ê·¸ ì£¼ì¸ê³µì´ë‹¤.

ì´ë“¤ì€ ì°¨ë¡€ë¡œ ë¦¬ìŠ¤íŠ¸, ì§‘í•©, í”„ë¡œê·¸ë˜ë¨¸ê°€ ì§€ì •í•œ ì»¬ë ‰ì…˜ íƒ€ì…ì„ ë°˜í™˜í•œë‹¤.

## ë¹ˆë„í‘œì—ì„œ ê°€ì¥ í”í•œ ë‹¨ì–´ 10ê°œë¥¼ ë½‘ì•„ë‚´ëŠ” ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸ ì½”ë“œ

```kotlin
private fun topTen(freq: Map<String, Long>): List<String> {
    return freq.keys.stream()
            .sorted(comparing(freq::getValue).reversed())
            .limit(10)
            .toList()
}
```

ë§ˆì§€ë§‰ì˜ `.toList()`ëŠ” kotlin `Streams.kt` ì•ˆì˜ í•¨ìˆ˜ì´ë©°, ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.

```kotlin
@SinceKotlin("1.2")
public fun <T> Stream<T>.toList(): List<T> = collect(Collectors.toList<T>())
```

ìœ„ ì½”ë“œì—ì„œ ì–´ë ¤ìš´ ë¶€ë¶„ì€ sortedì— ë„˜ê¸´ ë¹„êµì, ì¦‰ `comparing(freq::getValue).reversed()`ë¿ì´ë‹¤.

comparing ë©”ì„œë“œëŠ” í‚¤ ì¶”ì¶œ í•¨ìˆ˜ë¥¼ ë°›ëŠ” ë¹„êµì ìƒì„± ë©”ì„œë“œì´ë‹¤.

```java
public static <T, U extends Comparable<? super U>> Comparator<T> comparing(
            Function<? super T, ? extends U> keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator<T> & Serializable)
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    }
```

ì—¬ê¸°ì„œ í‚¤ ì¶”ì¶œ í•¨ìˆ˜ë¡œ ì“°ì¸ `freq::getValue`(ìë°”ì—ì„œëŠ” `freq::get`)ì€ ì…ë ¥ë°›ì€ ë‹¨ì–´(í‚¤)ë¥¼ ë¹ˆë„í‘œì—ì„œ ì°¾ì•„(ì¶”ì¶œ)

ê·¸ ë¹ˆë„ë¥¼ ë°˜í™˜í•œë‹¤.

```kotlin
// Returns the value for the given key or throws an exception if there is no such key in the map.
// If the map was created by withDefault, resorts to its defaultValue provider function instead of throwing an exception.
// Throws:
// NoSuchElementException - when the map doesn't contain a value for the specified key and no implicit default value was provided for that map.

@SinceKotlin("1.1")
public fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)
```

ê·¸ ë‹¤ìŒ ê°€ì¥ í”í•œ ë‹¨ì–´ê°€ ìœ„ë¡œ ì˜¤ë„ë¡ ë¹„êµì(comparing)ë¥¼ ì—­ìˆœ(reversed)ìœ¼ë¡œ ì •ë ¬í•œë‹¤(sorted).

## Collectorsì˜ ë‚˜ë¨¸ì§€ 36ê°œ ë©”ì„œë“œë“¤

_ì—¬ê¸°ì„œë¶€í„°ëŠ” ì§„ì§œë¡œ [https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html)ì˜ ë¬¸ì„œë¥¼ ë”°ë¼ê°€ë©´ì„œ ê°„ë‹¨íˆ ì •ë¦¬í•œ ë‚´ìš©ì´ë‹¤._

_í•„ìš”í•  ë•Œ ì½ìœ¼ë©´ ë  ê²ƒ ê°™ë‹¤. ğŸ™_

ê°€ì¥ ì¤‘ìš”í•œ ìˆ˜ì§‘ê¸° íŒ©í„°ë¦¬ëŠ” `toList`, `toSet`, `toMap`, `groupingBy`, `joining`ì´ë‹¤.

## í•µì‹¬ ì •ë¦¬

- ìŠ¤íŠ¸ë¦¼ íŒŒì´í”„ë¼ì¸ í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ì€ **ë¶€ì‘ìš© ì—†ëŠ” í•¨ìˆ˜ ê°ì²´**ì— ìˆë‹¤.
- ìŠ¤íŠ¸ë¦¼ë¿ ì•„ë‹ˆë¼ ìŠ¤íŠ¸ë¦¼ ê´€ë ¨ ê°ì²´ì— ê±´ë„¤ì§€ëŠ” ëª¨ë“  í•¨ìˆ˜ ê°ì²´ê°€ ë¶€ì‘ìš©ì´ ì—†ì–´ì•¼ í•œë‹¤.
- ì¢…ë‹¨ ì—°ì‚° ì¤‘ `forEach`ëŠ” ìŠ¤íŠ¸ë¦¼ì´ ìˆ˜í–‰í•œ ê³„ì‚° ê²°ê³¼ë¥¼ ë³´ê³ í•  ë•Œë§Œ ì´ìš©í•´ì•¼ í•œë‹¤.
  - ê³„ì‚° ìì²´ì—ëŠ” ì´ìš©í•˜ì§€ ë§ì.
- ê°€ì¥ ì¤‘ìš”í•œ ìˆ˜ì§‘ê¸° íŒ©í„°ë¦¬ëŠ” `toList`, `toSet`, `toMap`, `groupingBy`, `joining`ì´ë‹¤.
